{
  "language": "Solidity",
  "sources": {
    "@aragon/osx-commons-contracts/src/dao/IDAO.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IDAO\n/// @author Aragon X - 2022-2024\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\n/// @custom:security-contact sirt@aragon.org\ninterface IDAO {\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the contract.\n    /// @param _who The address of a EOA or contract to give the permissions.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if the address has permission, false if not.\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view returns (bool);\n\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\n    /// @param _metadata The IPFS hash of the new metadata object.\n    function setMetadata(bytes calldata _metadata) external;\n\n    /// @notice Emitted when the DAO metadata is updated.\n    /// @param metadata The IPFS hash of the new metadata object.\n    event MetadataSet(bytes metadata);\n\n    /// @notice Emitted when a standard callback is registered.\n    /// @param interfaceId The ID of the interface.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    event StandardCallbackRegistered(\n        bytes4 interfaceId,\n        bytes4 callbackSelector,\n        bytes4 magicNumber\n    );\n\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\n    /// @param _token The address of the token or address(0) in case of the native token.\n    /// @param _amount The amount of tokens to deposit.\n    /// @param _reference The reference describing the deposit reason.\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable;\n\n    /// @notice Emitted when a token deposit has been made to the DAO.\n    /// @param sender The address of the sender.\n    /// @param token The address of the deposited token.\n    /// @param amount The amount of tokens deposited.\n    /// @param _reference The reference describing the deposit reason.\n    event Deposited(\n        address indexed sender,\n        address indexed token,\n        uint256 amount,\n        string _reference\n    );\n\n    /// @notice Emitted when a native token deposit has been made to the DAO.\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// @param sender The address of the sender.\n    /// @param amount The amount of native tokens deposited.\n    event NativeTokenDeposited(address sender, uint256 amount);\n\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function setTrustedForwarder(address _trustedForwarder) external;\n\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\n    /// @return The trusted forwarder address.\n    function getTrustedForwarder() external view returns (address);\n\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\n    /// @param forwarder the new forwarder address.\n    event TrustedForwarderSet(address forwarder);\n\n    /// @notice Checks whether a signature is valid for a provided hash according to [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271).\n    /// @param _hash The hash of the data to be signed.\n    /// @param _signature The signature byte array associated with `_hash`.\n    /// @return Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid and `0xffffffff` if not.\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external returns (bytes4);\n\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\n    /// @param _interfaceId The ID of the interface.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the function signature.\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external;\n\n    /// @notice Removed function being left here to not corrupt the IDAO interface ID. Any call will revert.\n    /// @dev Introduced in v1.0.0. Removed in v1.4.0.\n    function setSignatureValidator(address) external;\n}\n"
    },
    "@aragon/osx-commons-contracts/src/executors/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n/// @param to The address to call.\n/// @param value The native token value to be sent with the call.\n/// @param data The bytes-encoded function selector and calldata for the call.\nstruct Action {\n    address to;\n    uint256 value;\n    bytes data;\n}\n\n/// @title IExecutor\n/// @author Aragon X - 2024\n/// @notice The interface required for Executors within the Aragon App DAO framework.\n/// @custom:security-contact sirt@aragon.org\ninterface IExecutor {\n    /// @notice Emitted when a proposal is executed.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function.\n    ///      A `Plugin` implementation can use it, for example, as a nonce.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 allowFailureMap,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return The array of results obtained from the executed actions in `bytes`.\n    /// @return The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) external returns (bytes[] memory, uint256);\n}\n"
    },
    "@aragon/osx-commons-contracts/src/permission/auth/auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {IDAO} from \"../../dao/IDAO.sol\";\n\n/// @title DAO Authorization Utilities\n/// @author Aragon X - 2022-2024\n/// @notice Provides utility functions for verifying if a caller has specific permissions in an associated DAO.\n/// @custom:security-contact sirt@aragon.org\n\n/// @notice Thrown if a call is unauthorized in the associated DAO.\n/// @param dao The associated DAO.\n/// @param where The context in which the authorization reverted.\n/// @param who The address (EOA or contract) missing the permission.\n/// @param permissionId The permission identifier.\nerror DaoUnauthorized(address dao, address where, address who, bytes32 permissionId);\n\n/// @notice A free function checking if a caller is granted permissions on a target contract via a permission identifier that redirects the approval to a `PermissionCondition` if this was specified in the setup.\n/// @param _where The address of the target contract for which `who` receives permission.\n/// @param _who The address (EOA or contract) owning the permission.\n/// @param _permissionId The permission identifier.\n/// @param _data The optional data passed to the `PermissionCondition` registered.\nfunction _auth(\n    IDAO _dao,\n    address _where,\n    address _who,\n    bytes32 _permissionId,\n    bytes calldata _data\n) view {\n    if (!_dao.hasPermission(_where, _who, _permissionId, _data))\n        revert DaoUnauthorized({\n            dao: address(_dao),\n            where: _where,\n            who: _who,\n            permissionId: _permissionId\n        });\n}\n"
    },
    "@aragon/osx-commons-contracts/src/permission/auth/DaoAuthorizableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\nimport {IDAO} from \"../../dao/IDAO.sol\";\nimport {_auth} from \"./auth.sol\";\n\n/// @title DaoAuthorizableUpgradeable\n/// @author Aragon X - 2022-2023\n/// @notice An abstract contract providing a meta-transaction compatible modifier for upgradeable or cloneable contracts to authorize function calls through an associated DAO.\n/// @dev Make sure to call `__DaoAuthorizableUpgradeable_init` during initialization of the inheriting contract.\n/// @custom:security-contact sirt@aragon.org\nabstract contract DaoAuthorizableUpgradeable is ContextUpgradeable {\n    /// @notice The associated DAO managing the permissions of inheriting contracts.\n    IDAO private dao_;\n\n    /// @notice Initializes the contract by setting the associated DAO.\n    /// @param _dao The associated DAO address.\n    // solhint-disable-next-line func-name-mixedcase\n    function __DaoAuthorizableUpgradeable_init(IDAO _dao) internal onlyInitializing {\n        dao_ = _dao;\n    }\n\n    /// @notice Returns the DAO contract.\n    /// @return The DAO contract.\n    function dao() public view returns (IDAO) {\n        return dao_;\n    }\n\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through the associated DAO's permission manager.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(dao_, address(this), _msgSender(), _permissionId, _msgData());\n        _;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IPermissionCondition\n/// @author Aragon X - 2021-2023\n/// @notice An interface to be implemented to support custom permission logic.\n/// @dev To attach a condition to a permission, the `grantWithCondition` function must be used and refer to the implementing contract's address with the `condition` argument.\n/// @custom:security-contact sirt@aragon.org\ninterface IPermissionCondition {\n    /// @notice Checks if a call is permitted.\n    /// @param _where The address of the target contract.\n    /// @param _who The address (EOA or contract) for which the permissions are checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data Optional data passed to the `PermissionCondition` implementation.\n    /// @return isPermitted Returns true if the call is permitted.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes calldata _data\n    ) external view returns (bool isPermitted);\n}\n"
    },
    "@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {IProtocolVersion} from \"../../utils/versioning/IProtocolVersion.sol\";\nimport {ProtocolVersion} from \"../../utils/versioning/ProtocolVersion.sol\";\nimport {IPermissionCondition} from \"./IPermissionCondition.sol\";\n\n/// @title PermissionCondition\n/// @author Aragon X - 2023\n/// @notice An abstract contract for non-upgradeable contracts instantiated via the `new` keyword  to inherit from to support customary permissions depending on arbitrary on-chain state.\n/// @custom:security-contact sirt@aragon.org\nabstract contract PermissionCondition is ERC165, IPermissionCondition, ProtocolVersion {\n    /// @notice Checks if an interface is supported by this or its parent contract.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPermissionCondition).interfaceId ||\n            _interfaceId == type(IProtocolVersion).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title PermissionLib\n/// @author Aragon X - 2021-2023\n/// @notice A library containing objects for permission processing.\n/// @custom:security-contact sirt@aragon.org\nlibrary PermissionLib {\n    /// @notice A constant expressing that no condition is applied to a permission.\n    address public constant NO_CONDITION = address(0);\n\n    /// @notice The types of permission operations available in the `PermissionManager`.\n    /// @param Grant The grant operation setting a permission without a condition.\n    /// @param Revoke The revoke operation removing a permission (that was granted with or without a condition).\n    /// @param GrantWithCondition The grant operation setting a permission with a condition.\n    enum Operation {\n        Grant,\n        Revoke,\n        GrantWithCondition\n    }\n\n    /// @notice A struct containing the information for a permission to be applied on a single target contract without a condition.\n    /// @param operation The permission operation type.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param permissionId The permission identifier.\n    struct SingleTargetPermission {\n        Operation operation;\n        address who;\n        bytes32 permissionId;\n    }\n\n    /// @notice A struct containing the information for a permission to be applied on multiple target contracts, optionally, with a condition.\n    /// @param operation The permission operation type.\n    /// @param where The address of the target contract for which `who` receives permission.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\n    /// @param permissionId The permission identifier.\n    struct MultiTargetPermission {\n        Operation operation;\n        address where;\n        address who;\n        address condition;\n        bytes32 permissionId;\n    }\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/extensions/governance/Addresslist.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {CheckpointsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\n\nimport {_uncheckedAdd, _uncheckedSub} from \"../../../utils/math/UncheckedMath.sol\";\n\n/// @title Addresslist\n/// @author Aragon X - 2021-2023\n/// @notice The majority voting implementation using a list of member addresses.\n/// @dev This contract inherits from `MajorityVotingBase` and implements the `IMajorityVoting` interface.\n/// @custom:security-contact sirt@aragon.org\nabstract contract Addresslist {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n\n    /// @notice The mapping containing the checkpointed history of the address list.\n    // solhint-disable-next-line named-parameters-mapping\n    mapping(address => CheckpointsUpgradeable.History) private _addresslistCheckpoints;\n\n    /// @notice The checkpointed history of the length of the address list.\n    CheckpointsUpgradeable.History private _addresslistLengthCheckpoints;\n\n    /// @notice Thrown when the address list update is invalid, which can be caused by the addition of an existing member or removal of a non-existing member.\n    /// @param member The array of member addresses to be added or removed.\n    error InvalidAddresslistUpdate(address member);\n\n    /// @notice Checks if an account is on the address list at a specific block number.\n    /// @param _account The account address being checked.\n    /// @param _blockNumber The block number.\n    /// @return Whether the account is listed at the specified block number.\n    function isListedAtBlock(\n        address _account,\n        uint256 _blockNumber\n    ) public view virtual returns (bool) {\n        return _addresslistCheckpoints[_account].getAtBlock(_blockNumber) == 1;\n    }\n\n    /// @notice Checks if an account is currently on the address list.\n    /// @param _account The account address being checked.\n    /// @return Whether the account is currently listed.\n    function isListed(address _account) public view virtual returns (bool) {\n        return _addresslistCheckpoints[_account].latest() == 1;\n    }\n\n    /// @notice Returns the length of the address list at a specific block number.\n    /// @param _blockNumber The specific block to get the count from. If `0`, then the latest checkpoint value is returned.\n    /// @return The address list length at the specified block number.\n    function addresslistLengthAtBlock(uint256 _blockNumber) public view virtual returns (uint256) {\n        return _addresslistLengthCheckpoints.getAtBlock(_blockNumber);\n    }\n\n    /// @notice Returns the current length of the address list.\n    /// @return The current address list length.\n    function addresslistLength() public view virtual returns (uint256) {\n        return _addresslistLengthCheckpoints.latest();\n    }\n\n    /// @notice Internal function to add new addresses to the address list.\n    /// @param _newAddresses The new addresses to be added.\n    function _addAddresses(address[] calldata _newAddresses) internal virtual {\n        for (uint256 i; i < _newAddresses.length; ) {\n            if (isListed(_newAddresses[i])) {\n                revert InvalidAddresslistUpdate(_newAddresses[i]);\n            }\n\n            // Mark the address as listed\n            _addresslistCheckpoints[_newAddresses[i]].push(1);\n\n            unchecked {\n                ++i;\n            }\n        }\n        _addresslistLengthCheckpoints.push(_uncheckedAdd, _newAddresses.length);\n    }\n\n    /// @notice Internal function to remove existing addresses from the address list.\n    /// @param _exitingAddresses The existing addresses to be removed.\n    function _removeAddresses(address[] calldata _exitingAddresses) internal virtual {\n        for (uint256 i; i < _exitingAddresses.length; ) {\n            if (!isListed(_exitingAddresses[i])) {\n                revert InvalidAddresslistUpdate(_exitingAddresses[i]);\n            }\n\n            // Mark the address as not listed\n            _addresslistCheckpoints[_exitingAddresses[i]].push(0);\n\n            unchecked {\n                ++i;\n            }\n        }\n        _addresslistLengthCheckpoints.push(_uncheckedSub, _exitingAddresses.length);\n    }\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[48] private __gap;\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/extensions/membership/IMembership.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IMembership\n/// @author Aragon X - 2022-2023\n/// @notice An interface to be implemented by DAO plugins that define membership.\n/// @custom:security-contact sirt@aragon.org\ninterface IMembership {\n    /// @notice Emitted when members are added to the DAO plugin.\n    /// @param members The list of new members being added.\n    event MembersAdded(address[] members);\n\n    /// @notice Emitted when members are removed from the DAO plugin.\n    /// @param members The list of existing members being removed.\n    event MembersRemoved(address[] members);\n\n    /// @notice Emitted to announce the membership being defined by a contract.\n    /// @param definingContract The contract defining the membership.\n    event MembershipContractAnnounced(address indexed definingContract);\n\n    /// @notice Checks if an account is a member of the DAO.\n    /// @param _account The address of the account to be checked.\n    /// @return Whether the account is a member or not.\n    /// @dev This function must be implemented in the plugin contract that introduces the members to the DAO.\n    function isMember(address _account) external view returns (bool);\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {Action} from \"../../../executors/IExecutor.sol\";\n\n/// @title IProposal\n/// @author Aragon X - 2022-2024\n/// @notice An interface to be implemented by DAO plugins that create and execute proposals.\n/// @custom:security-contact sirt@aragon.org\ninterface IProposal {\n    /// @notice Emitted when a proposal is created.\n    /// @param proposalId The ID of the proposal.\n    /// @param creator  The creator of the proposal.\n    /// @param startDate The start date of the proposal in seconds.\n    /// @param endDate The end date of the proposal in seconds.\n    /// @param metadata The metadata of the proposal.\n    /// @param actions The actions that will be executed if the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        address indexed creator,\n        uint64 startDate,\n        uint64 endDate,\n        bytes metadata,\n        Action[] actions,\n        uint256 allowFailureMap\n    );\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param proposalId The ID of the proposal.\n    event ProposalExecuted(uint256 indexed proposalId);\n\n    /// @notice Creates a new proposal.\n    /// @param _metadata The metadata of the proposal.\n    /// @param _actions The actions that will be executed after the proposal passes.\n    /// @param _startDate The start date of the proposal.\n    /// @param _endDate The end date of the proposal.\n    /// @param _data The additional abi-encoded data to include more necessary fields.\n    /// @return proposalId The id of the proposal.\n    function createProposal(\n        bytes memory _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external returns (uint256 proposalId);\n\n    /// @notice Whether proposal succeeded or not.\n    /// @dev Note that this must not include time window checks and only make a decision based on the thresholds.\n    /// @param _proposalId The id of the proposal.\n    /// @return Returns if proposal has been succeeded or not without including time window checks.\n    function hasSucceeded(uint256 _proposalId) external view returns (bool);\n\n    /// @notice Executes a proposal.\n    /// @param _proposalId The ID of the proposal to be executed.\n    function execute(uint256 _proposalId) external;\n\n    /// @notice Checks if a proposal can be executed.\n    /// @param _proposalId The ID of the proposal to be checked.\n    /// @return True if the proposal can be executed, false otherwise.\n    function canExecute(uint256 _proposalId) external view returns (bool);\n\n    /// @notice The human-readable abi format for extra params included in `data` of `createProposal`.\n    /// @dev Used for UI to easily detect what extra params the contract expects.\n    /// @return ABI of params in `data` of `createProposal`.\n    function customProposalParamsABI() external view returns (string memory);\n\n    /// @notice Returns the proposal count which determines the next proposal ID.\n    /// @dev This function is deprecated but remains in the interface for backward compatibility.\n    ///      It now reverts to prevent ambiguity.\n    /// @return The proposal count.\n    function proposalCount() external view returns (uint256);\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/extensions/proposal/ProposalUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport {IProposal} from \"./IProposal.sol\";\n\n/// @title ProposalUpgradeable\n/// @author Aragon X - 2022-2024\n/// @notice An abstract contract containing the traits and internal functionality to create and execute proposals\n///         that can be inherited by upgradeable DAO plugins.\n/// @custom:security-contact sirt@aragon.org\nabstract contract ProposalUpgradeable is IProposal, ERC165Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    error FunctionDeprecated();\n\n    /// @notice The incremental ID for proposals and executions.\n    CountersUpgradeable.Counter private proposalCounter;\n\n    /// @inheritdoc IProposal\n    function proposalCount() public view virtual override returns (uint256) {\n        revert FunctionDeprecated();\n    }\n\n    /// @notice Creates a proposal Id.\n    /// @dev Uses block number and chain id to ensure more probability of uniqueness.\n    /// @param _salt The extra salt to help with uniqueness.\n    /// @return The id of the proposal.\n    function _createProposalId(bytes32 _salt) internal view virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(block.chainid, block.number, address(this), _salt)));\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @dev In addition to the current interfaceId, also support previous version of the interfaceId\n    ///      that did not include the following functions:\n    ///      `createProposal`, `hasSucceeded`, `execute`, `canExecute`, `customProposalParamsABI`.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId ==\n            type(IProposal).interfaceId ^\n                IProposal.createProposal.selector ^\n                IProposal.hasSucceeded.selector ^\n                IProposal.execute.selector ^\n                IProposal.canExecute.selector ^\n                IProposal.customProposalParamsABI.selector ||\n            _interfaceId == type(IProposal).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables\n    ///         without shifting down storage in the inheritance chain\n    ///         (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IPlugin\n/// @author Aragon X - 2022-2024\n/// @notice An interface defining the traits of a plugin.\n/// @custom:security-contact sirt@aragon.org\ninterface IPlugin {\n    /// @notice Types of plugin implementations available within OSx.\n    enum PluginType {\n        UUPS,\n        Cloneable,\n        Constructable\n    }\n\n    /// @notice Specifies the type of operation to perform.\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    /// @notice Configuration for the target contract that the plugin will interact with, including the address and operation type.\n    /// @dev By default, the plugin typically targets the associated DAO and performs a `Call` operation. However, this\n    ///      configuration allows the plugin to specify a custom executor and select either `Call` or `DelegateCall` based on\n    ///      the desired execution context.\n    /// @param target The address of the target contract, typically the associated DAO but configurable to a custom executor.\n    /// @param operation The type of operation (`Call` or `DelegateCall`) to execute on the target, as defined by `Operation`.\n    struct TargetConfig {\n        address target;\n        Operation operation;\n    }\n\n    /// @notice Returns the plugin's type\n    function pluginType() external view returns (PluginType);\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {IERC1822ProxiableUpgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ERC165CheckerUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport {IProtocolVersion} from \"../utils/versioning/IProtocolVersion.sol\";\nimport {ProtocolVersion} from \"../utils/versioning/ProtocolVersion.sol\";\nimport {DaoAuthorizableUpgradeable} from \"../permission/auth/DaoAuthorizableUpgradeable.sol\";\nimport {IPlugin} from \"./IPlugin.sol\";\nimport {IDAO} from \"../dao/IDAO.sol\";\nimport {IExecutor, Action} from \"../executors/IExecutor.sol\";\n\n/// @title PluginUUPSUpgradeable\n/// @author Aragon X - 2022-2024\n/// @notice An abstract, upgradeable contract to inherit from when creating a plugin being deployed via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n/// @custom:security-contact sirt@aragon.org\nabstract contract PluginUUPSUpgradeable is\n    IPlugin,\n    ERC165Upgradeable,\n    UUPSUpgradeable,\n    DaoAuthorizableUpgradeable,\n    ProtocolVersion\n{\n    using ERC165CheckerUpgradeable for address;\n\n    // NOTE: When adding new state variables to the contract, the size of `_gap` has to be adapted below as well.\n\n    /// @notice Stores the current target configuration, defining the target contract and operation type for a plugin.\n    TargetConfig private currentTargetConfig;\n\n    /// @notice Thrown when target is of type 'IDAO', but operation is `delegateCall`.\n    /// @param targetConfig The target config to update it to.\n    error InvalidTargetConfig(TargetConfig targetConfig);\n\n    /// @notice Thrown when `delegatecall` fails.\n    error DelegateCallFailed();\n\n    /// @notice Thrown when initialize is called after it has already been executed.\n    error AlreadyInitialized();\n\n    /// @notice Emitted each time the TargetConfig is set.\n    event TargetSet(TargetConfig newTargetConfig);\n\n    /// @notice The ID of the permission required to call the `setTargetConfig` function.\n    bytes32 public constant SET_TARGET_CONFIG_PERMISSION_ID =\n        keccak256(\"SET_TARGET_CONFIG_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_PLUGIN_PERMISSION_ID = keccak256(\"UPGRADE_PLUGIN_PERMISSION\");\n\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice This ensures that the initialize function cannot be called during the upgrade process.\n    modifier onlyCallAtInitialization() {\n        if (_getInitializedVersion() != 0) {\n            revert AlreadyInitialized();\n        }\n\n        _;\n    }\n\n    /// @inheritdoc IPlugin\n    function pluginType() public pure override returns (PluginType) {\n        return PluginType.UUPS;\n    }\n\n    /// @notice Returns the currently set target contract.\n    /// @return TargetConfig The currently set target.\n    function getCurrentTargetConfig() public view virtual returns (TargetConfig memory) {\n        return currentTargetConfig;\n    }\n\n    /// @notice A convenient function to get current target config only if its target is not address(0), otherwise dao().\n    /// @return TargetConfig The current target config if its target is not address(0), otherwise returns dao().\"\n    function getTargetConfig() public view virtual returns (TargetConfig memory) {\n        TargetConfig memory targetConfig = currentTargetConfig;\n\n        if (targetConfig.target == address(0)) {\n            targetConfig = TargetConfig({target: address(dao()), operation: Operation.Call});\n        }\n\n        return targetConfig;\n    }\n\n    /// @notice Initializes the plugin by storing the associated DAO.\n    /// @param _dao The DAO contract.\n    // solhint-disable-next-line func-name-mixedcase\n    function __PluginUUPSUpgradeable_init(IDAO _dao) internal virtual onlyInitializing {\n        __DaoAuthorizableUpgradeable_init(_dao);\n    }\n\n    /// @dev Sets the target to a new target (`newTarget`).\n    ///      The caller must have the `SET_TARGET_CONFIG_PERMISSION_ID` permission.\n    /// @param _targetConfig The target Config containing the address and operation type.\n    function setTargetConfig(\n        TargetConfig calldata _targetConfig\n    ) public auth(SET_TARGET_CONFIG_PERMISSION_ID) {\n        _setTargetConfig(_targetConfig);\n    }\n\n    /// @notice Checks if an interface is supported by this or its parent contract.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPlugin).interfaceId ||\n            _interfaceId == type(IProtocolVersion).interfaceId ||\n            _interfaceId == type(IERC1822ProxiableUpgradeable).interfaceId ||\n            _interfaceId ==\n            this.setTargetConfig.selector ^\n                this.getTargetConfig.selector ^\n                this.getCurrentTargetConfig.selector ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Returns the address of the implementation contract in the [proxy storage slot](https://eips.ethereum.org/EIPS/eip-1967) slot the [UUPS proxy](https://eips.ethereum.org/EIPS/eip-1822) is pointing to.\n    /// @return The address of the implementation contract.\n    function implementation() public view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice Sets the target to a new target (`newTarget`).\n    /// @param _targetConfig The target Config containing the address and operation type.\n    function _setTargetConfig(TargetConfig memory _targetConfig) internal virtual {\n        // safety check to avoid setting dao as `target` with `delegatecall` operation\n        // as this would not work and cause the plugin to be bricked.\n        if (\n            _targetConfig.target.supportsInterface(type(IDAO).interfaceId) &&\n            _targetConfig.operation == Operation.DelegateCall\n        ) {\n            revert InvalidTargetConfig(_targetConfig);\n        }\n\n        currentTargetConfig = _targetConfig;\n\n        emit TargetSet(_targetConfig);\n    }\n\n    /// @notice Forwards the actions to the currently set `target` for the execution.\n    /// @dev If target is not set, passes actions to the dao.\n    /// @param _callId Identifier for this execution.\n    /// @param _actions actions that will be eventually called.\n    /// @param _allowFailureMap Bitmap-encoded number.\n    /// @return execResults address of the implementation contract.\n    /// @return failureMap address of the implementation contract.\n    function _execute(\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) internal virtual returns (bytes[] memory execResults, uint256 failureMap) {\n        TargetConfig memory targetConfig = getTargetConfig();\n\n        return\n            _execute(\n                targetConfig.target,\n                _callId,\n                _actions,\n                _allowFailureMap,\n                targetConfig.operation\n            );\n    }\n\n    /// @notice Forwards the actions to the `target` for the execution.\n    /// @param _target The address of the target contract.\n    /// @param _callId Identifier for this execution.\n    /// @param _actions actions that will be eventually called.\n    /// @param _allowFailureMap A bitmap allowing the execution to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    /// @param _op The type of operation (`Call` or `DelegateCall`) to be used for the execution.\n    /// @return execResults address of the implementation contract.\n    /// @return failureMap address of the implementation contract.\n    function _execute(\n        address _target,\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap,\n        Operation _op\n    ) internal virtual returns (bytes[] memory execResults, uint256 failureMap) {\n        if (_op == Operation.DelegateCall) {\n            bool success;\n            bytes memory data;\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (success, data) = _target.delegatecall(\n                abi.encodeCall(IExecutor.execute, (_callId, _actions, _allowFailureMap))\n            );\n\n            if (!success) {\n                if (data.length > 0) {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        let returndata_size := mload(data)\n                        revert(add(32, data), returndata_size)\n                    }\n                } else {\n                    revert DelegateCallFailed();\n                }\n            }\n            (execResults, failureMap) = abi.decode(data, (bytes[], uint256));\n        } else {\n            (execResults, failureMap) = IExecutor(_target).execute(\n                _callId,\n                _actions,\n                _allowFailureMap\n            );\n        }\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_PLUGIN_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    )\n        internal\n        virtual\n        override\n        auth(UPGRADE_PLUGIN_PERMISSION_ID)\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {PermissionLib} from \"../../permission/PermissionLib.sol\";\n\n// solhint-disable-next-line no-unused-import\nimport {IDAO} from \"../../dao/IDAO.sol\";\n\n/// @title IPluginSetup\n/// @author Aragon X - 2022-2023\n/// @notice The interface required for a plugin setup contract to be consumed by the `PluginSetupProcessor` for plugin installations, updates, and uninstallations.\n/// @custom:security-contact sirt@aragon.org\ninterface IPluginSetup {\n    /// @notice The data associated with a prepared setup.\n    /// @param helpers The address array of helpers (contracts or EOAs) associated with this plugin version after the installation or update.\n    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the installing or updating DAO.\n    struct PreparedSetupData {\n        address[] helpers;\n        PermissionLib.MultiTargetPermission[] permissions;\n    }\n\n    /// @notice The payload for plugin updates and uninstallations containing the existing contracts as well as optional data to be consumed by the plugin setup.\n    /// @param plugin The address of the `Plugin`.\n    /// @param currentHelpers The address array of all current helpers (contracts or EOAs) associated with the plugin to update from.\n    /// @param data The bytes-encoded data containing the input parameters for the preparation of update/uninstall as specified in the corresponding ABI on the version's metadata.\n    struct SetupPayload {\n        address plugin;\n        address[] currentHelpers;\n        bytes data;\n    }\n\n    /// @notice Prepares the installation of a plugin.\n    /// @param _dao The address of the installing DAO.\n    /// @param _data The bytes-encoded data containing the input parameters for the installation as specified in the plugin's build metadata JSON file.\n    /// @return plugin The address of the `Plugin` contract being prepared for installation.\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    function prepareInstallation(\n        address _dao,\n        bytes calldata _data\n    ) external returns (address plugin, PreparedSetupData memory preparedSetupData);\n\n    /// @notice Prepares the update of a plugin.\n    /// @param _dao The address of the updating DAO.\n    /// @param _fromBuild The build number of the plugin to update from.\n    /// @param _payload The relevant data necessary for the `prepareUpdate`. See above.\n    /// @return initData The initialization data to be passed to upgradeable contracts when the update is applied in the `PluginSetupProcessor`.\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    function prepareUpdate(\n        address _dao,\n        uint16 _fromBuild,\n        SetupPayload calldata _payload\n    ) external returns (bytes memory initData, PreparedSetupData memory preparedSetupData);\n\n    /// @notice Prepares the uninstallation of a plugin.\n    /// @param _dao The address of the uninstalling DAO.\n    /// @param _payload The relevant data necessary for the `prepareUninstallation`. See above.\n    /// @return permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the uninstalling DAO.\n    function prepareUninstallation(\n        address _dao,\n        SetupPayload calldata _payload\n    ) external returns (PermissionLib.MultiTargetPermission[] memory permissions);\n\n    /// @notice Returns the plugin implementation address.\n    /// @return The address of the plugin implementation contract.\n    /// @dev The implementation can be instantiated via the `new` keyword, cloned via the minimal proxy pattern (see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167)), or proxied via the UUPS proxy pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    function implementation() external view returns (address);\n}\n"
    },
    "@aragon/osx-commons-contracts/src/plugin/setup/PluginUpgradeableSetup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {IProtocolVersion} from \"../../utils/versioning/IProtocolVersion.sol\";\nimport {ProtocolVersion} from \"../../utils/versioning/ProtocolVersion.sol\";\nimport {IPluginSetup} from \"./IPluginSetup.sol\";\n\n/// @title PluginUpgradeableSetup\n/// @author Aragon X - 2022-2024\n/// @notice An abstract contract to inherit from to implement the plugin setup for upgradeable plugins, i.e, `PluginUUPSUpgradeable` being deployed via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822) and [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967)).\n/// @custom:security-contact sirt@aragon.org\nabstract contract PluginUpgradeableSetup is ERC165, IPluginSetup, ProtocolVersion {\n    /// @notice The address of the plugin implementation contract for initial block explorer verification\n    /// and to create [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) UUPS proxies from.\n    address internal immutable IMPLEMENTATION;\n\n    /// @notice Thrown when an update path is not available, for example, if this is the initial build.\n    /// @param fromBuild The build number to update from.\n    /// @param thisBuild The build number of this setup to update to.\n    error InvalidUpdatePath(uint16 fromBuild, uint16 thisBuild);\n\n    /// @notice The contract constructor, that setting the plugin implementation contract.\n    /// @param _implementation The address of the plugin implementation contract.\n    constructor(address _implementation) {\n        IMPLEMENTATION = _implementation;\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPluginSetup).interfaceId ||\n            _interfaceId == type(IProtocolVersion).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IPluginSetup\n    function implementation() public view returns (address) {\n        return IMPLEMENTATION;\n    }\n}\n"
    },
    "@aragon/osx-commons-contracts/src/utils/deployment/ProxyLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title ProxyLib\n/// @author Aragon X - 2024\n/// @notice A library containing methods for the deployment of proxies via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)) and minimal proxy pattern (see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167)).\n/// @custom:security-contact sirt@aragon.org\nlibrary ProxyLib {\n    using Address for address;\n    using Clones for address;\n\n    /// @notice Creates an [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) UUPS proxy contract pointing to a logic contract and allows to immediately initialize it.\n    /// @param _logic The logic contract the proxy is pointing to.\n    /// @param _initCalldata The initialization data for this contract.\n    /// @return uupsProxy The address of the UUPS proxy contract created.\n    /// @dev If `_initCalldata` is non-empty, it is used in a delegate call to the `_logic` contract. This will typically be an encoded function call initializing the storage of the proxy (see [OpenZeppelin ERC1967Proxy-constructor](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy-constructor-address-bytes-)).\n    function deployUUPSProxy(\n        address _logic,\n        bytes memory _initCalldata\n    ) internal returns (address uupsProxy) {\n        uupsProxy = address(new ERC1967Proxy({_logic: _logic, _data: _initCalldata}));\n    }\n\n    /// @notice Creates an [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167) minimal proxy contract, also known as clones, pointing to a logic contract and allows to immediately initialize it.\n    /// @param _logic The logic contract the proxy is pointing to.\n    /// @param _initCalldata The initialization data for this contract.\n    /// @return minimalProxy The address of the minimal proxy contract created.\n    /// @dev If `_initCalldata` is non-empty, it is used in a call to the clone contract. This will typically be an encoded function call initializing the storage of the contract.\n    function deployMinimalProxy(\n        address _logic,\n        bytes memory _initCalldata\n    ) internal returns (address minimalProxy) {\n        minimalProxy = _logic.clone();\n        if (_initCalldata.length > 0) {\n            minimalProxy.functionCall({data: _initCalldata});\n        }\n    }\n}\n"
    },
    "@aragon/osx-commons-contracts/src/utils/math/UncheckedMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @notice Adds two unsigned integers without checking the result for overflow errors (using safe math).\n/// @param a The first summand.\n/// @param b The second summand.\n/// @return The sum.\n/// @custom:security-contact sirt@aragon.org\nfunction _uncheckedAdd(uint256 a, uint256 b) pure returns (uint256) {\n    unchecked {\n        return a + b;\n    }\n}\n\n/// @notice Subtracts two unsigned integers without checking the result for overflow errors (using safe math).\n/// @param a The minuend.\n/// @param b The subtrahend.\n/// @return The difference.\n/// @custom:security-contact sirt@aragon.org\nfunction _uncheckedSub(uint256 a, uint256 b) pure returns (uint256) {\n    unchecked {\n        return a - b;\n    }\n}\n"
    },
    "@aragon/osx-commons-contracts/src/utils/metadata/MetadataExtensionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport {DaoAuthorizableUpgradeable} from \"../../permission/auth/DaoAuthorizableUpgradeable.sol\";\n\n/// @title MetadataExtensionUpgradeable\n/// @author Aragon X - 2024\n/// @notice An abstract, upgradeable contract for managing and retrieving metadata associated with a plugin.\n/// @dev Due to the requirements that already existing upgradeable plugins need to start inheritting from this,\n///      we're required to use hardcoded/specific slots for storage instead of sequential slots with gaps.\n/// @custom:security-contact sirt@aragon.org\nabstract contract MetadataExtensionUpgradeable is ERC165Upgradeable, DaoAuthorizableUpgradeable {\n    /// @notice The ID of the permission required to call the `setMetadata` function.\n    bytes32 public constant SET_METADATA_PERMISSION_ID = keccak256(\"SET_METADATA_PERMISSION\");\n\n    // keccak256(abi.encode(uint256(keccak256(\"osx-commons.storage.MetadataExtension\")) - 1)) & ~bytes32(uint256(0xff))\n    // solhint-disable-next-line  const-name-snakecase\n    bytes32 private constant MetadataExtensionStorageLocation =\n        0x47ff9796f72d439c6e5c30a24b9fad985a00c85a9f2258074c400a94f8746b00;\n\n    /// @notice Emitted when metadata is updated.\n    event MetadataSet(bytes metadata);\n\n    struct MetadataExtensionStorage {\n        bytes metadata;\n    }\n\n    function _getMetadataExtensionStorage()\n        private\n        pure\n        returns (MetadataExtensionStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := MetadataExtensionStorageLocation\n        }\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == this.setMetadata.selector ^ this.getMetadata.selector ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Allows to update only the metadata.\n    /// @param _metadata The utf8 bytes of a content addressing cid that stores plugin's information.\n    function setMetadata(bytes calldata _metadata) public virtual auth(SET_METADATA_PERMISSION_ID) {\n        _setMetadata(_metadata);\n    }\n\n    /// @notice Returns the metadata currently applied.\n    /// @return The The utf8 bytes of a content addressing cid.\n    function getMetadata() public view returns (bytes memory) {\n        MetadataExtensionStorage storage $ = _getMetadataExtensionStorage();\n        return $.metadata;\n    }\n\n    /// @notice Internal function to update metadata.\n    /// @param _metadata The utf8 bytes of a content addressing cid that stores contract's information.\n    function _setMetadata(bytes memory _metadata) internal virtual {\n        MetadataExtensionStorage storage $ = _getMetadataExtensionStorage();\n        $.metadata = _metadata;\n\n        emit MetadataSet(_metadata);\n    }\n}\n"
    },
    "@aragon/osx-commons-contracts/src/utils/versioning/IProtocolVersion.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IProtocolVersion\n/// @author Aragon X - 2022-2023\n/// @notice An interface defining the semantic Aragon OSx protocol version number.\n/// @custom:security-contact sirt@aragon.org\ninterface IProtocolVersion {\n    /// @notice Returns the semantic Aragon OSx protocol version number that the implementing contract is associated with.\n    /// @return _version Returns the semantic Aragon OSx protocol version number.\n    /// @dev This version number is not to be confused with the `release` and `build` numbers found in the `Version.Tag` struct inside the `PluginRepo` contract being used to version plugin setup and associated plugin implementation contracts.\n    function protocolVersion() external view returns (uint8[3] memory _version);\n}\n"
    },
    "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {IProtocolVersion} from \"./IProtocolVersion.sol\";\n\n/// @title ProtocolVersion\n/// @author Aragon X - 2023\n/// @notice An abstract, stateless, non-upgradeable contract providing the current Aragon OSx protocol version number.\n/// @dev Do not add any new variables to this contract that would shift down storage in the inheritance chain.\n/// @custom:security-contact sirt@aragon.org\nabstract contract ProtocolVersion is IProtocolVersion {\n    // IMPORTANT: Do not add any storage variable, see the above notice.\n\n    /// @inheritdoc IProtocolVersion\n    function protocolVersion() public pure returns (uint8[3] memory) {\n        return [1, 4, 0];\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport {Initializable} from \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary CheckpointsUpgradeable {\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\n     * block, the requested block number must be in the past, excluding the current block.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\n     * checkpoint is probably \"recent\", defined as being among the last sqrt(N) checkpoints where N is the number of\n     * checkpoints.\n     */\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        return _insert(self._checkpoints, SafeCastUpgradeable.toUint32(block.number), SafeCastUpgradeable.toUint224(value));\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(\n        History storage self\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._blockNumber, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(History storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._blockNumber <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._blockNumber == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165Upgradeable).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "src/IMultisig.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IMultisig\n/// @author Aragon X - 2022-2024\n/// @notice An interface for an on-chain multisig governance plugin in which a proposal passes\n///         if X out of Y approvals are met.\n/// @custom:security-contact sirt@aragon.org\ninterface IMultisig {\n    /// @notice Adds new members to the address list. Previously, it checks if the new address\n    ///         list length would be greater than `type(uint16).max`, the maximal number of approvals.\n    /// @param _members The addresses of the members to be added.\n    function addAddresses(address[] calldata _members) external;\n\n    /// @notice Removes existing members from the address list. Previously, it checks if the\n    ///         new address list length is at least as long as the minimum approvals parameter requires.\n    ///         Note that `minApprovals` is must be at least 1 so the address list cannot become empty.\n    /// @param _members The addresses of the members to be removed.\n    function removeAddresses(address[] calldata _members) external;\n\n    /// @notice Records an approval for a proposal and, if specified, attempts execution if certain conditions are met.\n    /// @param _proposalId The ID of the proposal to approve.\n    /// @param _tryExecution If `true`, attempts execution of the proposal after approval, without reverting on failure.\n    function approve(uint256 _proposalId, bool _tryExecution) external;\n\n    /// @notice Checks if an account is eligible to participate in a proposal vote.\n    ///         Confirms that the proposal is open, the account is listed as a member,\n    ///         and the account has not previously voted or approved this proposal.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _account The address of the account to check.\n    /// @return True if the account is eligible to vote.\n    function canApprove(uint256 _proposalId, address _account) external view returns (bool);\n\n    /// @notice Checks if a proposal can be executed.\n    /// @param _proposalId The ID of the proposal to be checked.\n    /// @return True if the proposal can be executed, false otherwise.\n    function canExecute(uint256 _proposalId) external view returns (bool);\n\n    /// @notice Returns whether the account has approved the proposal.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _account The account address to be checked.\n    /// @return The vote option cast by a voter for a certain proposal.\n    function hasApproved(uint256 _proposalId, address _account) external view returns (bool);\n\n    /// @notice Executes a proposal if all execution conditions are met.\n    /// @param _proposalId The ID of the proposal to be executed.\n    function execute(uint256 _proposalId) external;\n}\n"
    },
    "src/ListedCheckCondition.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {Multisig} from \"./Multisig.sol\";\n\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title ListedCheckCondition\n/// @author Aragon X - 2024\n/// @notice A condition contract that checks if an address is listed as a member in the associated Multisig contract.\n/// @custom:security-contact sirt@aragon.org\ncontract ListedCheckCondition is PermissionCondition {\n    /// @notice The immutable address of the Multisig plugin used for fetching plugin settings.\n    Multisig private immutable MULTISIG;\n\n    /// @notice Initializes the condition with the address of the Multisig plugin.\n    /// @param _multisig The address of the Multisig plugin that stores listing and other configuration settings.\n    constructor(address _multisig) {\n        MULTISIG = Multisig(_multisig);\n    }\n\n    /// @inheritdoc IPermissionCondition\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes calldata _data\n    ) public view override returns (bool) {\n        (_where, _data, _permissionId);\n\n        (bool onlyListed, ) = MULTISIG.multisigSettings();\n\n        if (onlyListed && !MULTISIG.isListed(_who)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"
    },
    "src/Multisig.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/* solhint-disable max-line-length */\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {IMembership} from \"@aragon/osx-commons-contracts/src/plugin/extensions/membership/IMembership.sol\";\nimport {Addresslist} from \"@aragon/osx-commons-contracts/src/plugin/extensions/governance/Addresslist.sol\";\nimport {ProposalUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/ProposalUpgradeable.sol\";\nimport {PluginUUPSUpgradeable} from \"@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {MetadataExtensionUpgradeable} from \"@aragon/osx-commons-contracts/src/utils/metadata/MetadataExtensionUpgradeable.sol\";\n\nimport {IMultisig} from \"./IMultisig.sol\";\n\n/* solhint-enable max-line-length */\n\n/// @title Multisig\n/// @author Aragon X - 2022-2024\n/// @notice The on-chain multisig governance plugin in which a proposal passes if X out of Y approvals are met.\n/// @dev v1.3 (Release 1, Build 3). For each upgrade, if the reinitialization step is required,\n///      increment the version numbers in the modifier for both the initialize and initializeFrom functions.\n/// @custom:security-contact sirt@aragon.org\ncontract Multisig is\n    IMultisig,\n    IMembership,\n    MetadataExtensionUpgradeable,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable,\n    Addresslist\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param approvals The number of approvals casted.\n    /// @param parameters The proposal-specific approve settings at the time of the proposal creation.\n    /// @param approvers The approves casted by the approvers.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    /// @param targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    struct Proposal {\n        bool executed;\n        uint16 approvals;\n        ProposalParameters parameters;\n        mapping(address => bool) approvers;\n        Action[] actions;\n        uint256 allowFailureMap;\n        TargetConfig targetConfig; // added in build 3.\n    }\n\n    /// @notice A container for the proposal parameters.\n    /// @param minApprovals The number of approvals required.\n    /// @param snapshotBlock The number of the block prior to the proposal creation.\n    /// @param startDate The timestamp when the proposal starts.\n    /// @param endDate The timestamp when the proposal expires.\n    struct ProposalParameters {\n        uint16 minApprovals;\n        uint64 snapshotBlock;\n        uint64 startDate;\n        uint64 endDate;\n    }\n\n    /// @notice A container for the plugin settings.\n    /// @param onlyListed Whether only listed addresses can create a proposal or not.\n    /// @param minApprovals The minimal number of approvals required for a proposal to pass.\n    struct MultisigSettings {\n        bool onlyListed;\n        uint16 minApprovals;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MULTISIG_INTERFACE_ID =\n        this.updateMultisigSettings.selector ^\n            bytes4(\n                keccak256(\n                    \"createProposal(bytes,(address,uint256,bytes)[],uint256,bool,bool,uint64,uint64)\"\n                )\n            ) ^\n            this.getProposal.selector;\n\n    /// @notice The ID of the permission required to call the\n    ///         `addAddresses`, `removeAddresses` and `updateMultisigSettings` functions.\n    bytes32 public constant UPDATE_MULTISIG_SETTINGS_PERMISSION_ID =\n        keccak256(\"UPDATE_MULTISIG_SETTINGS_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `createProposal` function.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PROPOSAL_PERMISSION_ID =\n        keccak256(\"EXECUTE_PROPOSAL_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    // solhint-disable-next-line named-parameters-mapping\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The current plugin settings.\n    MultisigSettings public multisigSettings;\n\n    /// @notice Keeps track at which block number the multisig settings have been changed the last time.\n    /// @dev This variable prevents a proposal from being created in the same block in which the multisig\n    ///      settings change.\n    uint64 public lastMultisigSettingsChange;\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown when a proposal doesn't exist.\n    /// @param proposalId The ID of the proposal which doesn't exist.\n    error NonexistentProposal(uint256 proposalId);\n\n    /// @notice Thrown if an approver is not allowed to cast an approve. This can be because the proposal\n    ///         - is not open,\n    ///         - was executed, or\n    ///         - the approver is not on the address list\n    /// @param proposalId The ID of the proposal.\n    /// @param sender The address of the sender.\n    error ApprovalCastForbidden(uint256 proposalId, address sender);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Thrown if the minimal approvals value is out of bounds (less than 1 or greater than the number of\n    ///         members in the address list).\n    /// @param limit The maximal value.\n    /// @param actual The actual value.\n    error MinApprovalsOutOfBounds(uint16 limit, uint16 actual);\n\n    /// @notice Thrown if the address list length is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error AddresslistLengthOutOfBounds(uint16 limit, uint256 actual);\n\n    /// @notice Thrown if the proposal with the same id already exists.\n    /// @param proposalId The id of the proposal.\n    error ProposalAlreadyExists(uint256 proposalId);\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Emitted when a proposal is approve by an approver.\n    /// @param proposalId The ID of the proposal.\n    /// @param approver The approver casting the approve.\n    event Approved(uint256 indexed proposalId, address indexed approver);\n\n    /// @notice Emitted when the plugin settings are set.\n    /// @param onlyListed Whether only listed addresses can create a proposal.\n    /// @param minApprovals The minimum amount of approvals needed to pass a proposal.\n    event MultisigSettingsUpdated(bool onlyListed, uint16 indexed minApprovals);\n\n    /// @notice Initializes Release 1, Build 3.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _members The addresses of the initial members to be added.\n    /// @param _multisigSettings The multisig settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and\n    ///     operation type(either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin`\n    ///     interface of `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function initialize(\n        IDAO _dao,\n        address[] calldata _members,\n        MultisigSettings calldata _multisigSettings,\n        TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(2) {\n        __PluginUUPSUpgradeable_init(_dao);\n\n        if (_members.length > type(uint16).max) {\n            revert AddresslistLengthOutOfBounds({limit: type(uint16).max, actual: _members.length});\n        }\n\n        _addAddresses(_members);\n        emit MembersAdded({members: _members});\n\n        _updateMultisigSettings(_multisigSettings);\n        _setMetadata(_pluginMetadata);\n\n        _setTargetConfig(_targetConfig);\n    }\n\n    /// @notice Reinitializes the Multisig after an upgrade from a previous build version. For each\n    ///         reinitialization step, use the `_fromBuild` version to decide which internal functions to call\n    ///         for reinitialization.\n    /// @dev WARNING: The contract should only be upgradeable through PSP to ensure that _fromBuild is not\n    ///      incorrectly passed, and that the appropriate permissions for the upgrade are properly configured.\n    /// @param _fromBuild The build version number of the previous implementation contract\n    ///     this upgrade is transitioning from.\n    /// @param _initData The initialization data to be passed to via `upgradeToAndCall`\n    ///     (see [ERC-1967](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Upgrade)).\n    function initializeFrom(uint16 _fromBuild, bytes calldata _initData) external reinitializer(2) {\n        if (_fromBuild < 3) {\n            (TargetConfig memory targetConfig, bytes memory pluginMetadata) = abi.decode(\n                _initData,\n                (TargetConfig, bytes)\n            );\n\n            _setTargetConfig(targetConfig);\n            _setMetadata(pluginMetadata);\n        }\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(\n        bytes4 _interfaceId\n    )\n        public\n        view\n        virtual\n        override(MetadataExtensionUpgradeable, PluginUUPSUpgradeable, ProposalUpgradeable)\n        returns (bool)\n    {\n        return\n            _interfaceId == MULTISIG_INTERFACE_ID ||\n            _interfaceId == type(IMultisig).interfaceId ||\n            _interfaceId == type(Addresslist).interfaceId ||\n            _interfaceId == type(IMembership).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IMultisig\n    /// @dev Requires the `UPDATE_MULTISIG_SETTINGS_PERMISSION_ID` permission.\n    function addAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        uint256 newAddresslistLength = addresslistLength() + _members.length;\n\n        // Check if the new address list length would be greater than `type(uint16).max`, the maximal number of\n        // approvals.\n        if (newAddresslistLength > type(uint16).max) {\n            revert AddresslistLengthOutOfBounds({\n                limit: type(uint16).max,\n                actual: newAddresslistLength\n            });\n        }\n\n        _addAddresses(_members);\n\n        emit MembersAdded({members: _members});\n    }\n\n    /// @inheritdoc IMultisig\n    /// @dev Requires the `UPDATE_MULTISIG_SETTINGS_PERMISSION_ID` permission.\n    function removeAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        uint16 newAddresslistLength = uint16(addresslistLength() - _members.length);\n\n        // Check if the new address list length would become less than the current minimum number of approvals required.\n        if (newAddresslistLength < multisigSettings.minApprovals) {\n            revert MinApprovalsOutOfBounds({\n                limit: newAddresslistLength,\n                actual: multisigSettings.minApprovals\n            });\n        }\n\n        _removeAddresses(_members);\n\n        emit MembersRemoved({members: _members});\n    }\n\n    /// @notice Updates the plugin settings.\n    /// @dev Requires the `UPDATE_MULTISIG_SETTINGS_PERMISSION_ID` permission.\n    /// @param _multisigSettings The new settings.\n    function updateMultisigSettings(\n        MultisigSettings calldata _multisigSettings\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        _updateMultisigSettings(_multisigSettings);\n    }\n\n    /// @notice Creates a new multisig proposal.\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    /// @param _metadata The metadata of the proposal.\n    /// @param _actions The actions that will be executed after the proposal passes.\n    /// @param _allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    /// @param _approveProposal If `true`, the sender will approve the proposal.\n    /// @param _tryExecution If `true`, execution is tried after the vote cast. The call does not revert if\n    ///     execution is not possible.\n    /// @param _startDate The start date of the proposal.\n    /// @param _endDate The end date of the proposal.\n    /// @return proposalId The ID of the proposal.\n    // solhint-disable-next-line code-complexity\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] calldata _actions,\n        uint256 _allowFailureMap,\n        bool _approveProposal,\n        bool _tryExecution,\n        uint64 _startDate,\n        uint64 _endDate\n    ) public auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint64 snapshotBlock;\n        unchecked {\n            // The snapshot block must be mined already to protect the transaction against backrunning transactions\n            // causing census changes.\n            snapshotBlock = block.number.toUint64() - 1;\n        }\n\n        // Revert if the settings have been changed in the same block as this proposal should be created in.\n        // This prevents a malicious party from voting with previous addresses and the new settings.\n        if (lastMultisigSettingsChange > snapshotBlock) {\n            revert ProposalCreationForbidden(_msgSender());\n        }\n\n        if (_startDate == 0) {\n            _startDate = block.timestamp.toUint64();\n        } else if (_startDate < block.timestamp.toUint64()) {\n            revert DateOutOfBounds({limit: block.timestamp.toUint64(), actual: _startDate});\n        }\n\n        if (_endDate < _startDate) {\n            revert DateOutOfBounds({limit: _startDate, actual: _endDate});\n        }\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        // Create the proposal\n        Proposal storage proposal_ = proposals[proposalId];\n\n        // Revert if a proposal with the given `proposalId` already exists.\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n        proposal_.parameters.snapshotBlock = snapshotBlock;\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minApprovals = multisigSettings.minApprovals;\n\n        proposal_.targetConfig = getTargetConfig();\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length; ) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_approveProposal) {\n            approve(proposalId, _tryExecution);\n        }\n\n        _emitProposalCreatedEvent(\n            _actions,\n            _metadata,\n            _allowFailureMap,\n            _startDate,\n            _endDate,\n            proposalId\n        );\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Calls a public function that requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] calldata _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external override returns (uint256 proposalId) {\n        // Custom parameters\n        uint256 _allowFailureMap;\n        bool _approveProposal;\n        bool _tryExecution;\n\n        if (_data.length != 0) {\n            (_allowFailureMap, _approveProposal, _tryExecution) = abi.decode(\n                _data,\n                (uint256, bool, bool)\n            );\n        }\n\n        // Calls a public function for permission check.\n        proposalId = createProposal(\n            _metadata,\n            _actions,\n            _allowFailureMap,\n            _approveProposal,\n            _tryExecution,\n            _startDate,\n            _endDate\n        );\n    }\n\n    /// @inheritdoc IProposal\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap, bool approveProposal, bool tryExecution)\";\n    }\n\n    /// @inheritdoc IMultisig\n    /// @dev If `_tryExecution` is `true`, the function attempts execution after recording the approval.\n    ///      Execution will only proceed if the proposal is no longer open, the minimum approval requirements are met,\n    ///      and the caller has been granted execution permission. If execution conditions are not met,\n    ///      the function does not revert.\n    function approve(uint256 _proposalId, bool _tryExecution) public {\n        address approver = _msgSender();\n        if (!_canApprove(_proposalId, approver)) {\n            revert ApprovalCastForbidden(_proposalId, approver);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // As the list can never become more than type(uint16).max (due to `addAddresses` check)\n        // It's safe to use unchecked as it would never overflow.\n        unchecked {\n            proposal_.approvals += 1;\n        }\n\n        proposal_.approvers[approver] = true;\n\n        emit Approved({proposalId: _proposalId, approver: approver});\n\n        if (!_tryExecution) {\n            return;\n        }\n\n        if (\n            _canExecute(_proposalId) &&\n            dao().hasPermission(address(this), approver, EXECUTE_PROPOSAL_PERMISSION_ID, msg.data)\n        ) {\n            _execute(_proposalId);\n        }\n    }\n\n    /// @inheritdoc IMultisig\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canApprove(uint256 _proposalId, address _account) external view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _canApprove(_proposalId, _account);\n    }\n\n    /// @inheritdoc IMultisig\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function canExecute(\n        uint256 _proposalId\n    ) external view virtual override(IMultisig, IProposal) returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        return _canExecute(_proposalId);\n    }\n\n    /// @inheritdoc IProposal\n    function hasSucceeded(uint256 _proposalId) external view virtual override returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        return proposal_.approvals >= proposal_.parameters.minApprovals;\n    }\n\n    /// @notice Returns all information for a proposal by its ID.\n    /// @param _proposalId The ID of the proposal.\n    /// @return executed Whether the proposal is executed or not.\n    /// @return approvals The number of approvals casted.\n    /// @return parameters The parameters of the proposal.\n    /// @return actions The actions to be executed to the `target` contract address.\n    /// @return allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert.\n    ///     If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts.\n    ///     A failure map value of 0 requires every action to not revert.\n    /// @return targetConfig Execution configuration, applied to the proposal when it was created. Added in build 3.\n    function getProposal(\n        uint256 _proposalId\n    )\n        public\n        view\n        returns (\n            bool executed,\n            uint16 approvals,\n            ProposalParameters memory parameters,\n            Action[] memory actions,\n            uint256 allowFailureMap,\n            TargetConfig memory targetConfig\n        )\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        executed = proposal_.executed;\n        approvals = proposal_.approvals;\n        parameters = proposal_.parameters;\n        actions = proposal_.actions;\n        allowFailureMap = proposal_.allowFailureMap;\n        targetConfig = proposal_.targetConfig;\n    }\n\n    /// @inheritdoc IMultisig\n    /// @dev May return false if the `_proposalId` or `_account` do not exist,\n    ///     as the function does not verify their existence.\n    function hasApproved(uint256 _proposalId, address _account) public view returns (bool) {\n        return proposals[_proposalId].approvers[_account];\n    }\n\n    /// @inheritdoc IMultisig\n    /// @dev Requires the `EXECUTE_PROPOSAL_PERMISSION_ID` permission.\n    /// @dev Reverts if the proposal is still open or if the minimum approval threshold has not been met.\n    function execute(\n        uint256 _proposalId\n    ) public override(IMultisig, IProposal) auth(EXECUTE_PROPOSAL_PERMISSION_ID) {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMembership\n    function isMember(address _account) external view returns (bool) {\n        return isListed(_account);\n    }\n\n    /// @notice Internal function to execute a proposal.\n    /// @dev It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    function _execute(uint256 _proposalId) internal {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        proposal_.executed = true;\n\n        _execute(\n            proposal_.targetConfig.target,\n            bytes32(_proposalId),\n            proposal_.actions,\n            proposal_.allowFailureMap,\n            proposal_.targetConfig.operation\n        );\n\n        emit ProposalExecuted(_proposalId);\n    }\n\n    /// @notice Checks if proposal exists or not.\n    /// @dev A proposal is considered to exist if its `snapshotBlock` in `parameters` is non-zero.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if proposal exists, otherwise false.\n    function _proposalExists(uint256 _proposalId) private view returns (bool) {\n        return proposals[_proposalId].parameters.snapshotBlock != 0;\n    }\n\n    /// @notice Internal function to check if an account can approve.\n    /// @dev It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _account The account to check.\n    /// @return Returns `true` if the given account can approve on a certain proposal and `false` otherwise.\n    function _canApprove(uint256 _proposalId, address _account) internal view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_isProposalOpen(proposal_)) {\n            // The proposal was executed already\n            return false;\n        }\n\n        if (!isListedAtBlock(_account, proposal_.parameters.snapshotBlock)) {\n            // The approver has no voting power.\n            return false;\n        }\n\n        if (proposal_.approvers[_account]) {\n            // The approver has already approved\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal can be executed.\n    /// @dev It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the proposal can be executed and `false` otherwise.\n    function _canExecute(uint256 _proposalId) internal view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Verify that the proposal has not been executed or expired.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        }\n\n        return proposal_.approvals >= proposal_.parameters.minApprovals;\n    }\n\n    /// @notice Internal function to check if a proposal is still open.\n    /// @param proposal_ The proposal struct.\n    /// @return True if the proposal is open, false otherwise.\n    function _isProposalOpen(Proposal storage proposal_) internal view returns (bool) {\n        uint64 currentTimestamp64 = block.timestamp.toUint64();\n        return\n            !proposal_.executed &&\n            proposal_.parameters.startDate <= currentTimestamp64 &&\n            proposal_.parameters.endDate >= currentTimestamp64;\n    }\n\n    /// @notice Internal function to update the plugin settings.\n    /// @param _multisigSettings The new settings.\n    function _updateMultisigSettings(MultisigSettings calldata _multisigSettings) internal {\n        uint16 addresslistLength_ = uint16(addresslistLength());\n\n        if (_multisigSettings.minApprovals > addresslistLength_) {\n            revert MinApprovalsOutOfBounds({\n                limit: addresslistLength_,\n                actual: _multisigSettings.minApprovals\n            });\n        }\n\n        if (_multisigSettings.minApprovals < 1) {\n            revert MinApprovalsOutOfBounds({limit: 1, actual: _multisigSettings.minApprovals});\n        }\n\n        multisigSettings = _multisigSettings;\n        lastMultisigSettingsChange = block.number.toUint64();\n\n        emit MultisigSettingsUpdated({\n            onlyListed: _multisigSettings.onlyListed,\n            minApprovals: _multisigSettings.minApprovals\n        });\n    }\n\n    /// @dev Helper function to avoid stack too deep.\n    function _emitProposalCreatedEvent(\n        Action[] memory _actions,\n        bytes memory _metadata,\n        uint256 _allowFailureMap,\n        uint64 _startDate,\n        uint64 _endDate,\n        uint256 _proposalId\n    ) private {\n        emit ProposalCreated(\n            _proposalId,\n            _msgSender(),\n            _startDate,\n            _endDate,\n            _metadata,\n            _actions,\n            _allowFailureMap\n        );\n    }\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[47] private __gap;\n}\n"
    },
    "src/MultisigSetup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/* solhint-disable max-line-length */\nimport {PermissionLib} from \"@aragon/osx-commons-contracts/src/permission/PermissionLib.sol\";\nimport {IPluginSetup} from \"@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol\";\nimport {PluginUpgradeableSetup} from \"@aragon/osx-commons-contracts/src/plugin/setup/PluginUpgradeableSetup.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\n\nimport {ProxyLib} from \"@aragon/osx-commons-contracts/src/utils/deployment/ProxyLib.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\n\nimport {ListedCheckCondition} from \"./ListedCheckCondition.sol\";\n\nimport {Multisig} from \"./Multisig.sol\";\n\n/* solhint-enable max-line-length */\n\n/// @title MultisigSetup\n/// @author Aragon X - 2022-2024\n/// @notice The setup contract of the `Multisig` plugin.\n/// @dev v1.3 (Release 1, Build 3)\n/// @custom:security-contact sirt@aragon.org\ncontract MultisigSetup is PluginUpgradeableSetup {\n    using ProxyLib for address;\n\n    /// @notice The ID of the permission required to call the `execute` function on a DAO.\n    bytes32 private constant EXECUTE_PERMISSION_ID = keccak256(\"EXECUTE_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `upgradeToAndCall` function.\n    bytes32 private constant UPGRADE_PLUGIN_PERMISSION_ID = keccak256(\"UPGRADE_PLUGIN_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setTargetConfig` function.\n    bytes32 private constant SET_TARGET_CONFIG_PERMISSION_ID =\n        keccak256(\"SET_TARGET_CONFIG_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setMetadata` function on a DAO.\n    bytes32 private constant SET_METADATA_PERMISSION_ID = keccak256(\"SET_METADATA_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `updateMultisigSettings` function.\n    bytes32 private constant UPDATE_MULTISIG_SETTINGS_PERMISSION_ID =\n        keccak256(\"UPDATE_MULTISIG_SETTINGS_PERMISSION\");\n\n    /// @notice A special address encoding permissions that are valid for any address `who` or `where`.\n    address private constant ANY_ADDR = address(type(uint160).max);\n\n    /// @notice The contract constructor, that deploys the `Multisig` plugin logic contract.\n    constructor() PluginUpgradeableSetup(address(new Multisig())) {}\n\n    /// @inheritdoc IPluginSetup\n    function prepareInstallation(\n        address _dao,\n        bytes calldata _data\n    ) external returns (address plugin, PreparedSetupData memory preparedSetupData) {\n        // Decode `_data` to extract the params needed for deploying and initializing `Multisig` plugin.\n        (\n            address[] memory members,\n            Multisig.MultisigSettings memory multisigSettings,\n            IPlugin.TargetConfig memory targetConfig,\n            bytes memory pluginMetadata\n        ) = abi.decode(_data, (address[], Multisig.MultisigSettings, IPlugin.TargetConfig, bytes));\n\n        // Deploy and initialize the plugin UUPS proxy.\n        plugin = IMPLEMENTATION.deployUUPSProxy(\n            abi.encodeCall(\n                Multisig.initialize,\n                (IDAO(_dao), members, multisigSettings, targetConfig, pluginMetadata)\n            )\n        );\n\n        // Deploy a ListedCheckCondition contract.\n        address listedCheckCondition = address(new ListedCheckCondition(plugin));\n\n        // Prepare permissions\n        PermissionLib.MultiTargetPermission[]\n            memory permissions = new PermissionLib.MultiTargetPermission[](6);\n\n        // Set permissions to be granted.\n        // Grant the list of permissions of the plugin to the DAO.\n        permissions[0] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Grant,\n            where: plugin,\n            who: _dao,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: UPDATE_MULTISIG_SETTINGS_PERMISSION_ID\n        });\n\n        permissions[1] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Grant,\n            where: _dao,\n            who: plugin,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: EXECUTE_PERMISSION_ID\n        });\n\n        permissions[2] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.GrantWithCondition,\n            where: plugin,\n            who: ANY_ADDR,\n            condition: listedCheckCondition,\n            permissionId: Multisig(IMPLEMENTATION).CREATE_PROPOSAL_PERMISSION_ID()\n        });\n\n        permissions[3] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Grant,\n            where: plugin,\n            who: _dao,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: SET_TARGET_CONFIG_PERMISSION_ID\n        });\n\n        permissions[4] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Grant,\n            where: plugin,\n            who: _dao,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: SET_METADATA_PERMISSION_ID\n        });\n\n        permissions[5] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Grant,\n            where: plugin,\n            who: ANY_ADDR,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: Multisig(IMPLEMENTATION).EXECUTE_PROPOSAL_PERMISSION_ID()\n        });\n\n        preparedSetupData.permissions = permissions;\n\n        preparedSetupData.helpers = new address[](1);\n        preparedSetupData.helpers[0] = listedCheckCondition;\n    }\n\n    /// @inheritdoc IPluginSetup\n    /// @dev Revoke the upgrade plugin permission to the DAO for all builds prior the current one (3).\n    function prepareUpdate(\n        address _dao,\n        uint16 _fromBuild,\n        SetupPayload calldata _payload\n    )\n        external\n        override\n        returns (bytes memory initData, PreparedSetupData memory preparedSetupData)\n    {\n        if (_fromBuild < 3) {\n            address listedCheckCondition = address(new ListedCheckCondition(_payload.plugin));\n\n            PermissionLib.MultiTargetPermission[]\n                memory permissions = new PermissionLib.MultiTargetPermission[](5);\n\n            permissions[0] = PermissionLib.MultiTargetPermission({\n                operation: PermissionLib.Operation.Revoke,\n                where: _payload.plugin,\n                who: _dao,\n                condition: PermissionLib.NO_CONDITION,\n                permissionId: UPGRADE_PLUGIN_PERMISSION_ID\n            });\n\n            permissions[1] = PermissionLib.MultiTargetPermission({\n                operation: PermissionLib.Operation.GrantWithCondition,\n                where: _payload.plugin,\n                who: ANY_ADDR,\n                condition: listedCheckCondition,\n                permissionId: Multisig(IMPLEMENTATION).CREATE_PROPOSAL_PERMISSION_ID()\n            });\n\n            permissions[2] = PermissionLib.MultiTargetPermission({\n                operation: PermissionLib.Operation.Grant,\n                where: _payload.plugin,\n                who: _dao,\n                condition: PermissionLib.NO_CONDITION,\n                permissionId: SET_TARGET_CONFIG_PERMISSION_ID\n            });\n\n            permissions[3] = PermissionLib.MultiTargetPermission({\n                operation: PermissionLib.Operation.Grant,\n                where: _payload.plugin,\n                who: _dao,\n                condition: PermissionLib.NO_CONDITION,\n                permissionId: SET_METADATA_PERMISSION_ID\n            });\n\n            permissions[4] = PermissionLib.MultiTargetPermission({\n                operation: PermissionLib.Operation.Grant,\n                where: _payload.plugin,\n                who: ANY_ADDR,\n                condition: PermissionLib.NO_CONDITION,\n                permissionId: Multisig(IMPLEMENTATION).EXECUTE_PROPOSAL_PERMISSION_ID()\n            });\n\n            preparedSetupData.permissions = permissions;\n\n            preparedSetupData.helpers = new address[](1);\n            preparedSetupData.helpers[0] = listedCheckCondition;\n\n            initData = abi.encodeCall(Multisig.initializeFrom, (_fromBuild, _payload.data));\n        }\n    }\n\n    /// @inheritdoc IPluginSetup\n    function prepareUninstallation(\n        address _dao,\n        SetupPayload calldata _payload\n    ) external view returns (PermissionLib.MultiTargetPermission[] memory permissions) {\n        // Prepare permissions\n        permissions = new PermissionLib.MultiTargetPermission[](6);\n\n        // Set permissions to be Revoked.\n        permissions[0] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Revoke,\n            where: _payload.plugin,\n            who: _dao,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: UPDATE_MULTISIG_SETTINGS_PERMISSION_ID\n        });\n\n        permissions[1] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Revoke,\n            where: _dao,\n            who: _payload.plugin,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: EXECUTE_PERMISSION_ID\n        });\n\n        permissions[2] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Revoke,\n            where: _payload.plugin,\n            who: _dao,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: SET_TARGET_CONFIG_PERMISSION_ID\n        });\n\n        permissions[3] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Revoke,\n            where: _payload.plugin,\n            who: _dao,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: SET_METADATA_PERMISSION_ID\n        });\n\n        permissions[4] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Revoke,\n            where: _payload.plugin,\n            who: ANY_ADDR,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: Multisig(IMPLEMENTATION).CREATE_PROPOSAL_PERMISSION_ID()\n        });\n\n        permissions[5] = PermissionLib.MultiTargetPermission({\n            operation: PermissionLib.Operation.Revoke,\n            where: _payload.plugin,\n            who: ANY_ADDR,\n            condition: PermissionLib.NO_CONDITION,\n            permissionId: Multisig(IMPLEMENTATION).EXECUTE_PROPOSAL_PERMISSION_ID()\n        });\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "mode": "3"
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "detectMissingLibraries": false,
    "forceEVMLA": false,
    "enableEraVMExtensions": false,
    "libraries": {}
  }
}